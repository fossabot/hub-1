diff --git a/server/filestore.go b/server/filestore.go
index 1aaf65a8..318c7ca3 100644
--- a/server/filestore.go
+++ b/server/filestore.go
@@ -32,11 +32,13 @@ import (
 	"os"
 	"path"
 	"sort"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
 
 	"github.com/minio/highwayhash"
+	"github.com/plgd-dev/cqrs/protobuf/eventbus"
 )
 
 type FileStoreConfig struct {
@@ -695,6 +697,63 @@ func (fs *fileStore) enableLastMsgBlockForWriting() error {
 	return nil
 }
 
+// Will return message for the given sequence number.
+func (fs *fileStore) lookup(seq uint64) (*fileStoredMsg, error) {
+	fmt.Printf("fileStore.lookup: seq = %v\n", seq)
+	if fs.closed {
+		return nil, ErrStoreClosed
+	}
+	// Indicates we want first msg.
+	if seq == 0 {
+		return nil, ErrStoreEOF
+	}
+	// Make sure to snapshot here.
+	lseq := fs.state.LastSeq
+	mb := fs.selectMsgBlock(seq)
+
+	if mb == nil {
+		var err = ErrStoreEOF
+		if seq <= lseq {
+			err = ErrStoreMsgNotFound
+		}
+		return nil, err
+	}
+	// TODO(dlc) - older design had a check to prefetch when we knew we were
+	// loading in order and getting close to end of current mb. Should add
+	// something like it back in.
+	return mb.fetchMsg(seq)
+}
+
+func (fs *fileStore) checkOptimisticConcurrencyException(msg []byte) error {
+	lastMsg, err := fs.lookup(fs.state.LastSeq)
+	if err != nil && err != ErrStoreEOF {
+		fmt.Printf("fileStore.checkOptimisticConcurrencyException: lookup: %v\n", err)
+		return err
+	}
+	var ev eventbus.Event
+	err = ev.Unmarshal(msg)
+	if err != nil {
+		return err
+	}
+	if lastMsg == nil {
+		fmt.Printf("fileStore.checkOptimisticConcurrencyException: lastMsg == nil\n")
+		if ev.Version == 0 {
+			return nil
+		}
+		return fmt.Errorf("evenstore: invalid version(%v) of aggregateid(%v)", ev.Version, ev.AggregateId)
+	}
+	var lastEv eventbus.Event
+	err = lastEv.Unmarshal(lastMsg.msg)
+	if err != nil {
+		return err
+	}
+	if lastEv.Version+1 != ev.Version {
+		return fmt.Errorf("evenstore: concurrency exception: last version(%v), next version(%v) of aggregateid(%v)", lastEv.Version, ev.Version, ev.AggregateId)
+	}
+	fmt.Printf("fileStore.checkOptimisticConcurrencyException: lastEv=%+v ev=%+v\n", lastEv, ev)
+	return nil
+}
+
 // Store stores a message. We hold the main filestore lock for any write operation.
 func (fs *fileStore) StoreMsg(subj string, hdr, msg []byte) (uint64, int64, error) {
 	fs.mu.Lock()
@@ -703,6 +762,14 @@ func (fs *fileStore) StoreMsg(subj string, hdr, msg []byte) (uint64, int64, erro
 		fs.mu.Unlock()
 		return 0, 0, ErrStoreClosed
 	}
+	fmt.Printf("fileStore.StoreMsg: subj=%v\n", subj)
+
+	if strings.HasSuffix(subj, ".events") {
+		if err := fs.checkOptimisticConcurrencyException(msg); err != nil {
+			fs.mu.Unlock()
+			return 0, 0, err
+		}
+	}
 
 	// Check if we are discarding new messages when we reach the limit.
 	if fs.cfg.Discard == DiscardNew {
